syntax = "proto3";
import "common.proto";

package starknet.receipt;

message MessageToL1 {
  starknet.common.Felt252          from_address = 1;
  repeated starknet.common.Felt252 payload      = 2;
  EthereumAddress                  to_address   = 3;
}

message EthereumAddress {
  bytes elements = 1;
}

message Receipt {
  message ExecutionResources {
    message BuiltinCounter {
      uint32 bitwise     = 1;
      uint32 ecdsa       = 2;
      uint32 ec_op       = 3;
      uint32 pedersen    = 4;
      uint32 range_check = 5;
      uint32 poseidon    = 6;
      uint32 keccak      = 7;
      uint32 output      = 8;
    }

    BuiltinCounter builtins     = 1;
    uint32         steps        = 2;
    uint32         memory_holes = 3;
  }

  message Common {
    starknet.common.Hash    transaction_hash    = 1;
    starknet.common.Felt252 actual_fee          = 2;
    repeated MessageToL1    messages_sent       = 3;
    ExecutionResources      execution_resources = 4;
    string                  revert_reason       = 5;
  }


  message Invoke {
    Common common = 1;
  }

  message L1Handler {
    Common               common   = 1;
    starknet.common.Hash msg_hash = 2;
  }

  message Declare {
    Common common = 1;
  }

  message Deploy {
    Common                  common           = 1;
    starknet.common.Felt252 contract_address = 2;
  }

  message DeployAccount {
    Common                  common           = 1;
    starknet.common.Felt252 contract_address = 2;
  }

  oneof type {
    Invoke        invoke            = 1;
    L1Handler     l1_handler        = 2;
    Declare       declare           = 3;
    Deploy        deprecated_deploy = 4;
    DeployAccount deploy_account    = 5;
  }
}

message ReceiptsRequest {
  starknet.common.Iteration iteration = 1;
}

message Receipts {
    repeated Receipt items = 2;
}

// Responses are sent ordered by the order given in the request.
message ReceiptsResponse {
    oneof receipt_message {
        Receipt             receipt = 1;
        starknet.common.Fin fin     = 2; // Fin is sent after the peer sent all the data or when it encountered a block that it doesn't have its receipts.
    }
}
