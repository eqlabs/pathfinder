use std::path::{Path, PathBuf};

use p2p::libp2p::identity::Keypair;
use serde::Deserialize;
use zeroize::Zeroizing;

/// Loads the keypair from an identity configuration file or generates a new
/// keypair in memory.
pub fn load_or_generate(identity_config_file: Option<PathBuf>) -> anyhow::Result<Keypair> {
    Ok(match identity_config_file {
        Some(path) => {
            let config = Zeroizing::new(IdentityConfig::from_file(path.as_path())?);
            let private_key = Zeroizing::new(base64::decode(config.private_key.as_bytes())?);
            Keypair::from_protobuf_encoding(&private_key)?
        }
        None => {
            tracing::info!("No private key configured, generating a new one");
            Keypair::generate_ed25519()
        }
    })
}

#[derive(Clone, Deserialize)]
struct IdentityConfig {
    pub private_key: String,
}

impl IdentityConfig {
    pub fn from_file(path: &Path) -> anyhow::Result<Self> {
        Ok(serde_json::from_str(&std::fs::read_to_string(path)?)?)
    }
}

impl zeroize::Zeroize for IdentityConfig {
    fn zeroize(&mut self) {
        self.private_key.zeroize()
    }
}
